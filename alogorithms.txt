Algorithm palindrome:
1. Start
2. Receive the value for USERS as arguments
3. Initialize String CONTAINER=""
4. append USERS[INDEX] to CONTAINER
5. Repeat Step 4 until INDEX is 0 from USERS.Length
6. Check IF USERS = NEW_USERS, then return palindrome
7. Otherwise return Not a palindrome
8. Stop

Algorithm Armstrong:
12

1+8>>9

121

1+8+1>>10

153
1+125+ 27   >> 


2 Sum problem:
[1,8,5,7,2]
target=10

find: 8 and 2

first=0     1
second=0+1  8,5,7,2

first=1     8
second=2    5,7,2   >> 8,2

first=2     5
second=3    7,2

first=3     7
second=4    2

O(2n):
while:
    body1
while:
    body2


Algorithm: O(n2)
1. Start
2. Get the list and target as parameter
3. Initialize variable second=first+1
4. SUM first+second position of list
5. Check IF SUM=target, then Display the first and second and return
6. Repeat Step 4 and 5 Until second = len(list)
7. Repeat Step 6 range first=0 to first < len(list)
8. Otherwise, Display No pair found
9. Stop


Selection sort:
1. Start
2. Get the myList as parameters
3. Initialize Compare=Hold+1
4. Check IF Compare<Hold, then swap
5. Repeat step 4 until Compare < len(myList)
6. Repeat Step 3 to 5 range of Hold=0 Hold < len(myList)
7. Stop


Finding Duplicates:
1. Start
2. Receive the Paragraph as paramters
3. Split by space
4. Initialize Compare=Hold+1
5. Check IF Compare==Hold, then Display the word
6. Repeat step 4 until Compare < len(Paragraph)
7. Repeat Step 3 to 5 range of Hold=0 Hold < len(Paragraph)
8. Stop

Sorting algorithms:
	User friendly: using loops
		Selection, bubble, insertion,...
	Efficient		: divide and conquer
		Quick, heap, merge,.....

Selection sort:
	s		c
	0 >> 1,2,3,4,5
	1 >> 2,3,4,5
	2 >> 3,4,5
	3 >> 4,5
	4 >> 5

	  0		   1  		  2		  3		  4		 5
	8.9		12.8 	1.1 		9.0 		45.1 	2.3
	 s 		  		  c	
	1.1           12.8	8.9		9.0		45.1		2.3
	  s						 		  		 c
	1.1           12.8	8.9		9.0		45.1		2.3
	   		    s		  c
	1.1           8.9		12.8		9.0		45.1		2.3
	                    s		                  		        	 c
	1.1           2.3		12.8		9.0		45.1		8.9
	                    s		                  		        	 c
	1.1           2.3		12.8		9.0		45.1		8.9
	                    		   s             c  		        	 
	1.1           2.3		9.0		12.8		45.1		8.9
	                    		   s               		        	 c
	1.1           2.3		8.9		12.8		45.1		9.0
	                    		   s               		        	 c
	1.1           2.3		8.9		12.8		45.1		9.0
	                    		                  s		    c    	 
	1.1           2.3		8.9		12.8		45.1		9.0
	                    		                  s		         	 c
	1.1           2.3		8.9		9.0		45.1		12.8
	                    		                  s		         	 c
	1.1           2.3		8.9		9.0		45.1		12.8
	                    		                  		  s       	 c
	1.1           2.3		8.9		9.0		12.8		45.1
	                    		                  		  s       	 c


[MongoDB,Flask,Jinja,DJango,Python,Mongoose]


Quick Sort: O(nlogn)
-1	0		   1  		  2		  3		  4		 5
	8.9		12.8 	1.1 		9.0 		45.1 	2.3
i	s										e | P.D
        c,i

	0		   1  		  2		  3		  4		 5
	8.9		12.8 	1.1 		9.0 		45.1 	2.3
         s,i               c								e | P.D

	0		   1  		  2		  3		  4		 5
	8.9		12.8 	1.1 		9.0 		45.1 	2.3
         s               i,c								e | P.D

	0		   1  		  2		  3		  4		 5
	8.9		12.8 	1.1 		9.0 		45.1 	2.3
         s               i		c						e | P.D

	0		   1  		  2		  3		  4		 5
	8.9		12.8 	1.1 		9.0 		45.1 	2.3
    s               i				c				e | P.D

	0		   1  		  2		  3		  4		 5
	8.9		12.8 	9.0 		1.1 		45.1 	2.3
    s               		i		c				e | P.D

	0		   1  		  2		  3		  4		 5
	8.9		12.8 	9.0 		1.1 		45.1 	2.3
    s               		i				c		e | P.D

	0		   1  	2		    3		  4		    5
	8.9		12.8 	9.0 		45.1	1.1 		2.3
    s               				i		c		e | P.D


swap between i+1 and end
	
	0		   1  		  2		  3		  4		 5
	8.9		12.8 	9.0 		45.1	2.3 		1.1
							 i		i+1		P.D

	0		   1  		  2		  3		  4		 5
	8.9		12.8 	9.0 		45.1	2.3 		1.1
							 i		i+1		P.D
									P.P

0-3	>> p.D 45.1




Quick Sort:
1. Start
2. Initialize pivotalData = myList[end], initial=start-1
3. Initialize current=start
4. Check if current>pivotalData, then swap current with initial+1
5. Repeat step 4 until current < end
6. Swap between myList[end] with myList[initial+1]
7. return initial+1 as pivotal point


8. Initialize pivotalPoint with Step 7
9. Split myList start to pivotalPoint-1, then perform Step 1 to 7
10. Split myList pivotalPoint+1 to end, then perform Step 1 to 7
11. Recursivly perform step 8 to 10 until start<end
12. Stop

